---
layout: post
title:  "베디의 OCP와 전략패턴"
subtitle: "베디의 OCP와 전략패턴을 시청하고 정리해 보았습니다."
categories: development
tags: spring
comments: true
---

##@ if-else의 문제점

- 변경, 확장이 될 수록 코드가 복잡해진다.
- 코드를 수정하거나 수정할 위치를 찾는데 오래 걸린다.
- 실수로 추가하지 않고 누락하는 부분이 생길 가능성이 있다.

### OCP (Open Close Principle)

객체지향의 5대원칙 SOLID에서 O에 해당하는 OCP가 있다.

소프트웨어 구성 요소(컴포넌트, 클래스, 모듈, 함수)는 확장에 대해서는 개방되어야 하지만 변경에 대해서는 폐쇄되어야 한다.

기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다는 뜻이다.

확장을 하거나 기능을 변경할때마다 기존의 코드가 계속 바뀌면  

#### OCP를 적용하는 두가지 방법

1. 상속(is-a)

상속같은 경우는 상위클래스와 하위클래스가 강력하게 밀접한 관계에 있기때문에

상위클래스가 변경되면 하위클래스에도 영향을 미친다.

이러한 것을 `깨지기 쉬운 상위클래스 문제`라고 한다.

따라서 상속보단 컴포지션 방법을 추천한다.

1. 컴포지션(has-a)

1. 변경(확장)될 것과 변하지 않을 것을 엄격히 구분
1. 이 두 모듈이 만나는 지점에 인터페이스를 정의
1. 구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성


